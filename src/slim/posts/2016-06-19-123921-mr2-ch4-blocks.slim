.meta-data title Metaprogramming Ruby 2 - ch4 - Blocks
.meta-data datetime 2016-06-19 12:39:21
.meta-data tags mp,book_mr2,note,ruby
.meta-data category coding
.meta-data link mr2-ch4-blocks
.meta-data file 2016-06-19-123921-mr2-ch4-blocks
.meta-data template post
.meta-data end

h1 å‰è¨€

p é€™æ˜¯ Metaprogramming Ruby 2 çš„é–±è®€ç­†è¨˜ï¼Œåªæœƒè¨˜éŒ„æˆ‘è¦ºå¾—é‡è¦çš„åœ°æ–¹ã€‚å¦‚æœä½ æƒ³è¦äº†è§£å®Œæ•´çš„å…§å®¹æˆ–æ˜¯æƒ³è®“Rubyç¨‹å¼åšä¸€äº›ç¥å¥‡çš„äº‹ï¼Œå¼·çƒˆæ¨è–¦å»è®€è®€é€™æœ¬æ›¸ã€‚

h1 The Day of the Blocks
h2 Todayâ€™s Roadmap
h2 The Basics of Blocks
pre
  code.ruby
    | def say(who, word)
        if block_given?
    = "\n" + '    "#{who}: #{yield(word)}"' + "\n"
    |   else
    = "\n" + '    "#{who}: #{word}"' + "\n"
    |   end
      end
    = "\n\n" + 'p say(\'A\', \'Hi\') { |w| "#{w}~~~" }' + "\n"
    | p say('B', 'Hi')

h1 Quiz: Ruby#
h2 The using Keyword
h2 The Challenge
h2 Quiz Solution

h1 Blocks Are Closures

p ç•¶ç¨‹å¼åœ¨åŸ·è¡Œçš„çš„æ™‚å€™ï¼Œå¯èƒ½éœ€è¦ä¸€äº›æ‰€è¬‚çš„åŸ·è¡Œç’°å¢ƒ environment ï¼Œä¾‹å¦‚ï¼šlocal variablesã€instance variablesã€selfâ€¦ç­‰ï¼Œé€™äº›åˆç¨±åš bindings ã€‚ç•¶ä¸€å€‹ block è¦æº–å‚™åŸ·è¡Œçš„æ™‚å€™ï¼Œå¯¦éš›ä¸Šå°±æ˜¯åŒ…å«äº†ä¸€æ®µç¨‹å¼ç¢¼èˆ‡ä¸€æ•´çµ„ bindings ã€‚

pre
  code.ruby
    | a = "a in the top"

      def say(word)
        a = "a in the method" # 1
        p a # a in the method
        yield(word)
        p a # a in the method
      end

      p a # a in the top

      say('Hi') do |w|
        a = "a in the block" # 2
        b = "b in the block" # 3
    = "\n" + '  p "#{w}, #{a}, #{b}"  # Hi, a in the block, b in the block' + "\n"
    | end

      p a # a in the block # 4
      p b # undefined local variable or method `b' for main:Object (NameError) # 5
      
p ç”±ä¸Šé¢çš„ç¯„ä¾‹å¯ä»¥çœ‹åˆ°è®Šæ•¸èˆ‡blockä¹‹é–“scopeçš„è®ŠåŒ–

ul
  li # 1ï¼šæ˜¯ say çš„å€åŸŸè®Šæ•¸ï¼Œèˆ‡å¤–é¢çš„aæ²’æœ‰é—œä¿‚ï¼Œå¦å¤–åœ¨yieldçš„å‰å¾Œaéƒ½æ²’è¢«æ”¹è®Šï¼Œæ‰€ä»¥yieldæ‰€åœ¨çš„scopeä¸æœƒè¢«blockå½±éŸ¿ã€‚
  li # 2ï¼šæ˜¯ block è£¡å®šç¾©çš„aï¼Œé€™æ™‚å€™å®ƒæœƒæ”¹æ‰å¤–å±¤çš„a(å¾#4å¯ä»¥çœ‹å‡ºä¾†)ï¼Œä¹Ÿå°±æ˜¯å¤–å±¤çš„aå·²ç¶“è®Šæˆa in the blockã€‚
  li # 3ï¼šæ˜¯ block è£¡å®šç¾©çš„å€åŸŸè®Šæ•¸ï¼Œç•¶é›¢é–‹blockä¹‹å¾Œå°±ç„¡æ³•ä½¿ç”¨(å¾#5å¯ä»¥çœ‹å‡ºä¾†)ã€‚

p block æœ‰æ”¹æ‰æ‰€åœ¨ scope çš„ç‰¹æ€§ï¼Œæ‰€ä»¥æˆ‘å€‘ç¨± block æ˜¯ä¸€å€‹ closure ã€‚

h2 Scope
p 
  | ç•¶ç¨‹å¼åŸ·è¡Œåˆ°ä¸€åŠé€²è¡Œä¸­æ–·æ™‚ï¼Œç›®å‰æ‰€çœ‹åˆ°çš„ä¸€åˆ‡å³ç¨±åš scope ï¼Œä¾‹å¦‚ï¼šbindingsã€local variablesã€ç›®å‰æ‰€åœ¨çš„object(ä¹Ÿå°±æ˜¯æ‰€è¬‚çš„self)èˆ‡å°æ‡‰çš„instance variablesèˆ‡methodsï¼Œå¦å¤–é‚„æœ‰ç›®å‰å·²ç¶“å®šç¾©çš„constantsèˆ‡global variablesã€‚
h3 Changing Scope

pre
  code.ruby
    | v1 = 1
    
      p local_variables # [:v1, :a] # 1

      class A

        v2 = 2
        p local_variables # [:v2] # 2

        def say
          v3 = 3
          p local_variables #[:v3] # 3
        end

        p local_variables # [:v2] # 4
      end

      p local_variables # [:v1, :a] # 5

      a = A.new
      a.say

      p local_variables # [:v1, :a] # 6
p 
  | ä¸Šé¢çš„åŸ·è¡Œçµæœæœƒæ˜¯ï¼š
pre
  code.nohighlight
    | [:v1, :a] # 1 top-level scope é€™å€‹çµæœé‚„è »è®“æˆ‘é©šè¨çš„ï¼Œæˆ‘ä»¥ç‚ºåªæœƒæœ‰[:v1]â€¦
      [:v2]     # 2 class A scope
      [:v2]     # 4 class A scope
      [:v1, :a] # 5 top-level scope
      [:v3]     # 3 method say scope
      [:v1, :a] # 6 top-level scope
p 
  | å¯ä»¥å¾ä¸Šé¢çš„çµæœçœ‹åˆ°scopeçš„è½‰æ›ã€‚åœ¨Rubyä¸­ï¼Œå…§å±¤çš„scopeç„¡æ³•å–å¾—å¤–å±¤scopeçš„è®Šæ•¸ï¼Œä¹Ÿå°±æ˜¯èªªéš¨è‘—scopeçš„åˆ‡æ›ï¼Œbindingsä¹Ÿæœƒè·Ÿè‘—è¢«åˆ‡æ›ï¼Œä¸éä¸æ˜¯æ‰€æœ‰çš„bindingséƒ½æœƒæ›´æ–°ï¼Œä¾‹å¦‚åœ¨æŸå€‹ç‰©ä»¶çš„methodä¸­å‘¼å«å¦ä¸€å€‹ç›¸åŒç‰©ä»¶çš„methodï¼Œå‰‡å°æ‡‰çš„instance variableä¸¦ä¸æœƒæ›´æ–°ï¼Œç›¸å°æ–¼local variableï¼Œlocal variablesåœ¨scopeæ¯æ¬¡åˆ‡æ›æ™‚éƒ½æœƒæ›´æ–°ã€‚å¦å¤–è¦æ³¨æ„çš„æ˜¯method scopeåœ¨methodè¢«å‘¼å«çš„æ™‚å€™æœƒè¢«å»ºç«‹ï¼Œç•¶methodåŸ·è¡Œå®Œæ™‚ï¼Œmethod scopeä¹Ÿæœƒè·Ÿè‘—çµæŸï¼Œæ‰€ä»¥ç•¶å†æ¬¡å‘¼å«ç›¸åŒçš„methodæ™‚ï¼Œmethod scopeæœƒè¢«é‡æ–°å»ºç«‹ï¼Œå› æ­¤æ–°èˆŠçš„method scopeå½¼æ­¤ä¹‹é–“çš„è®Šæ•¸æ˜¯æ²’æœ‰é—œè¯çš„ã€‚
  
h2 Global Variables and Top-Level Instance Variables

p 
  | Global variablesæ˜¯ä»»ä½•çš„scopeéƒ½å¯ä»¥å­˜å–çš„è®Šæ•¸ï¼Œå°±æ˜¯å› ç‚ºå®ƒåœ¨ä»»ä½•åœ°æ–¹éƒ½å¯ä»¥è¢«å­˜å–ï¼Œæ‰€ä»¥æœƒè®“ç¨‹å¼è®Šå¾—é›£ä»¥ç†è§£èˆ‡ç¶­è­·(å› ç‚ºä½ ä¸çŸ¥é“é€™å€‹è®Šæ•¸åˆ°åº•è¢«èª°æ”¹äº†ï¼Œæˆ–æ˜¯åœ¨ä»€éº¼æ™‚å€™è¢«æ”¹)ã€‚è€Œå¦‚æœæœ‰éœ€è¦ï¼Œä½ å¯ä»¥ç”¨Top-level instance variablesä¾†å–ä»£global variableã€‚
pre
  code.ruby
    | $v_global = 1
      @v_instance = 1

      def say
        $v_global += 1
        @v_instance += 1
      end

      p $v_global # 1
      p @v_instance # 1

      say

      p $v_global # 2
      p @v_instance # 2

      class A
        def talk
          $v_global += 1
          # @v_instance += 1 # undefined method `+' for nil:NilClass (NoMethodError)
          p $v_global # 3
          p @v_instance # nil
        end
      end

      a = A.new
      a.talk

      p $v_global # 3
      p @v_instance # 2
p 
  | ä¸Šé¢çš„ä¾‹å­å¯ä»¥çœ‹çš„å‡ºä¾†ï¼Œtop-level instance variableåœ¨åˆ‡æ›åˆ°class scopeçš„æ™‚å€™ä¹Ÿæœƒè¢«åˆ‡æ›æˆclassçš„instance variableï¼Œä¹Ÿå°±æ˜¯åœ¨talké€™å€‹methodä¸­è®€åˆ°çš„@v_instanceä¸æ˜¯top-levelçš„instance variableï¼Œè€Œæ˜¯class Açš„instance variableã€‚æ‰€ä»¥ç›¸è¼ƒæ–¼global variableï¼Œtop-level instance variableæœƒæ¯”è¼ƒå®‰å…¨(é›–ç„¶é‚„æ˜¯å»ºè­°å°‘ç”¨å•¦)ã€‚

h2 Scope Gates

p 
  | æœ‰å¹¾å€‹åœ°æ–¹æœƒé€²è¡Œscopeçš„åˆ‡æ›ï¼š
ul
  li Class definitions
  li Module definitions
  li Methods
p 
  | è€Œé€™äº›å°æ‡‰çš„keywordï¼šclassã€moduleèˆ‡defï¼Œæˆ‘å€‘ç¨±åš Scope Gate ã€‚å¦å¤–class, moduleèˆ‡methodåˆ‡æ›scopeçš„æ™‚æ©Ÿé»ä¹Ÿä¸å¤ªä¸€æ¨£ï¼Œclassæˆ–moduleæœƒåœ¨é€²å…¥definitionçš„åœ°æ–¹å°±æœƒç«‹åˆ»åˆ‡æ›åˆ°classæˆ–moduleçš„scopeï¼Œè€Œmethod scopeåªæœ‰åœ¨é€™å€‹methodè¢«å‘¼å«çš„æ™‚å€™æ‰æœƒåˆ‡æ›åˆ°method scopeã€‚

p 
  | åˆ‡æ›scopeçš„æ™‚å€™ï¼Œå°æ‡‰çš„bindingsä¹Ÿæœƒè·Ÿè‘—åˆ‡æ›ï¼Œé‚£å¦‚æœè¦åœ¨ä¸åŒçš„scopeä¹‹é–“å…±äº«è®Šæ•¸ï¼Œé€™å°±æ˜¯blockçš„ç¯„ç–‡äº†ã€‚

h2 Flattening the Scope

pre
  code.ruby
    | v1 = 1

      class A
    = "\n" + '  p "#{v1}" # undefined local variable or method `v1\' for A:Class (NameError)' + "\n"
    |   def say
    = "\n" + '    p "#{v1}" # undefined local variable or method `v1\' for #<A:0x007fd3ed07ab98> (NameError)' + "\n"
    |   end
      end

      a = A.new
      a.say
p 
  | æˆ‘å€‘æƒ³è¦åœ¨classèˆ‡methodä¸­ä½¿ç”¨top-levelçš„local variable v1ï¼Œä¸Šé¢çš„å¯«æ³•å› ç‚ºscopeçš„é—œä¿‚è€Œç„¡æ³•åšåˆ°ã€‚é€™æ™‚å€™æˆ‘å€‘å¯ä»¥æ”¹æˆä¸‹é¢çš„å¯«æ³•ï¼š
pre
  code.ruby
    | v1 = 1
      A = Class.new do
    = "\n" + '  p "#{v1}"' + "\n"
    |   define_method(:say) do
    = "\n" + '    p "#{v1}"' + "\n"
    |   end
      end

      a = A.new
      a.say
p 
  | å› ç‚ºblockä¸¦ä¸æ˜¯ Scope Gateï¼Œæ‰€ä»¥classçš„å®£å‘Šæ”¹æˆ 
  code
    | Class.new
  | çš„æ–¹å¼ä¾†å®£å‘Šï¼Œè€Œmethodçš„å®šç¾©å‰‡æ˜¯ä½¿ç”¨ Dynamical Method çš„æ–¹å¼ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨ 
  code
    | define_method
  | çš„æ–¹å¼ä¾†å®£å‘Šï¼Œé‚£éº¼å°±å¯ä»¥åšåˆ°è®Šæ•¸çš„å…±äº«äº†ã€‚é€™å€‹æŠ€å·§é€šå¸¸ç¨±åš nested lexical scopes(lexicalæ„æ€æ˜¯ã€Œè©å½™ä¸Šçš„ã€ï¼Œä¹Ÿå°±æ˜¯èªªå®ƒé›–ç„¶çœ‹èµ·ä¾†åƒæ˜¯scopeï¼Œä½†å¯¦éš›ä¸Šå»ä¸æ˜¯)ï¼Œåˆç¨±ç‚º flattening the scopeï¼Œç°¡ç¨±ç‚º
  span.mk-blue
    | Flat Scope
  | ã€‚

h3 Sharing the Scope
p 
  | æœ‰äº† Flat Scopeï¼Œæˆ‘å€‘å°±å¯ä»¥ä½¿ç”¨scopeçš„ç‰¹æ€§æ§åˆ¶è®Šæ•¸å¯ä»¥è®Šæ•¸çœ‹åˆ°çš„ç¯„åœã€‚ä¾‹å¦‚ä¸‹é¢é€™å€‹ä¾‹å­ï¼š
pre
  code.ruby
    | def setup_counter
        counter = 0

        Kernel.send(:define_method, :add_count) do |size = 1|
          counter += size
        end

        Kernel.send(:define_method, :get_count) do
          counter
        end
      end

      setup_counter

      p get_count
      add_count
      add_count(5)
      p get_count
p 
  | counter é€™å€‹ local variable å› ç‚º scope çš„é—œä¿‚åªæœ‰ setup_counter æ‰çœ‹çš„åˆ°ï¼Œè€Œåˆä½¿ç”¨ Flat Scope çš„æ–¹å¼åœ¨ Kernel ä¸­å¡äº†å…©å€‹ method å¯ä»¥çœ‹çš„åˆ° counter ï¼Œæ‰€ä»¥å”¯ä¸€å¯ä»¥å­˜å– counter çš„æ–¹å¼å°±åªæœ‰ä½¿ç”¨ add_count èˆ‡ get_count ã€‚é€™å€‹æŠ€å·§åˆç¨±åš
  span.mk-blue
    | Sharing Scope
  | ã€‚

h2 Closures Wrap-Up

h1 instance_eval()

pre
  code.ruby
    | class A
        def initialize
          @word = 'Hi'
        end

        def say
          @word
        end
        
        private

        def murmur
          'Mmm...'
        end
      end

      a = A.new
      p a.say

      a.instance_eval do
        @word = 'Hello'
        p murmur
      end

      p a.say
pre
  code.nohighlight
    | "Hi"
      "Mmm..."
      "Hello"
p 
  | BasicObject#instance_eval ç›¸ç•¶æ–¼åœ¨ class ä¸­é–‹ä¸€å€‹ blockï¼Œå…¶ä¸­çš„ self(scope ä¸­é è¨­çš„ receiver) å³æ˜¯å°æ‡‰çš„ classã€‚é€™æ„å‘³è‘—åœ¨é€™å€‹ block ä¸­å¯ä»¥å­˜å– class çš„ instance variable èˆ‡ private methodã€‚å› ç‚ºé€™å€‹ block å¯ä»¥ç›´æ¥å­˜å– class å…§çš„ bindingsï¼Œæ‰€ä»¥åˆç¨±é€™å€‹ block ç‚º
  span.mk-blue
    | Context Probe
  | ã€‚

h2 Breaking Encapsulation
p 
  | ç”±ä¸Šé¢çš„ç¨‹å¼ç¢¼å¯ä»¥ç™¼ç¾ Context Probe æ ¹æœ¬å°±æ˜¯å°è£çš„ç ´å£è€…(åŸæ–‡é‚„ç”¨äº† wreak havoc on encapsulation! é€™æ¨£çš„æ–‡å­—å•Šï¼Œç¬‘)ï¼Œä¸éæœ‰æ™‚å€™éœ€è¦å­˜å– class å…§éƒ¨çš„è³‡è¨Šæ™‚(ä¾‹å¦‚è¦åšä¸€å€‹é¡ä¼¼pryçš„åŠŸèƒ½)ï¼Œå°è£åè€Œæœƒæˆç‚ºé˜»ç¤™ï¼Œé€™æ™‚å€™ Context Probe å°±æ˜¯ä¸€æ¢æ·å¾‘ã€‚

h2 instance_exec

pre
  code.ruby
    | class A
        def initialize
          @a = 'aaa'
        end
      end

      class B
        def say
          @b = 'bbb'
          A.new.instance_eval do
    = "\n" + '      "@a = #{@a}, @b = #{@b}"' + "\n"
    |     end
        end
      end

      b = B.new
      p b.say # "@a = aaa, @b = "
p 
  | å¾ä¸Šé¢çš„ä¾‹å­ç™¼ç¾æˆ‘å€‘æƒ³åœ¨ A.new.instance_eval ä¸­åŒæ™‚å„²å­˜ B çš„ instance variable @b æ˜¯åšä¸åˆ°çš„ï¼Œå› ç‚ºåœ¨ block ä¸­å·²ç¶“åˆ‡æˆ class A çš„ scopeï¼Œclass A ä¸­ä¸¦æ²’æœ‰ @b é€™å€‹ instance variableï¼Œæ‰€ä»¥ç•¶ç„¶è®€ä¸åˆ° @b çš„å€¼ï¼Œé€™æ™‚å€™æˆ‘å€‘å¯ä»¥æ”¹ç”¨ BasicObject#instance_execï¼Œå®ƒå¯ä»¥åˆ©ç”¨åƒæ•¸çš„æ–¹å¼å°‡å€¼å‚³å…¥åˆ° block ä¸­ã€‚

pre
  code.ruby
    | class A
        def initialize
          @a = 'aaa'
        end
      end

      class B
        def say
          @b = 'bbb'
          A.new.instance_exec(@b) do |b|
    = "\n" + '      "@a = #{@a}, @b = #{b}"' + "\n"
    |     end
        end
      end

      b = B.new
      p b.say # "@a = aaa, @b = bbb"

h3 The Padrino Example

p 
  | é€™è£¡èˆ‰äº† Padrino æ¸¬è©¦ä½¿ç”¨ instance_eval çš„ä¾‹å­ï¼Œç‚ºäº†æ–¹ä¾¿æ¸¬è©¦è€Œç›´æ¥ä½¿ç”¨ instance_eval æ›´æ”¹ instance variable çš„å€¼ã€‚å°±å¦‚åŒä½œè€…é€™è£¡æåˆ°çš„ï¼Œå°è£åœ¨ ruby ä¸­èˆ‡å…¶å®ƒçš„åŠŸèƒ½ä¸€æ¨£éƒ½å¯ä»¥æœ‰å½ˆæ€§çš„ä½¿ç”¨æˆ–è€…å¿½ç•¥ï¼Œè€Œå¯«ç¨‹å¼çš„äººå¿…é ˆè¦åšå‡ºé¸æ“‡ã€‚

h2 Clean Rooms

p 
  | æœ‰æ™‚å€™æˆ‘å€‘æœƒå»ºç«‹ä¸€äº› class æ˜¯å°ˆé–€çµ¦ instance_eval ä¾†ä½¿ç”¨ï¼Œæˆ‘å€‘ç¨±åš
  span.mk-blue
    | Clean Room
  | ã€‚ç†è«–ä¸Šï¼ŒClean Room ä¸­ä¸æœƒåŒ…å«ä»»ä½•çš„ instance variable èˆ‡ methodï¼Œè€Œæ˜¯å®Œå…¨é  Context Probe å°‡ç¨‹å¼ç¢¼å¯«å…¥åˆ° Clean Room ä¸­ã€‚ä½œè€…æåˆ°å¯ä»¥æœ‰ä¸€äº› method æ˜¯ç‚ºäº†æ–¹ä¾¿ä½¿ç”¨è€ŒåŠ ä¸Šå»çš„ï¼Œä½†å»ºè­°é‚„æ˜¯ä¸è¦ï¼Œå› ç‚ºæœ‰å¯èƒ½å¤–éƒ¨å‚³å…¥ç›¸åŒåç¨±çš„ method è€Œé€ æˆå½±éŸ¿ã€‚è€Œ Clean Room æœ€å¥½çš„å€™é¸è€…å°±æ˜¯ BasicObjectï¼Œå› ç‚ºå®ƒåŒæ™‚ä¹Ÿæ˜¯ä¸€å€‹ Blank Slate (ä¹Ÿå°±æ˜¯åŒ…å«æœ€å°‘ method çš„ç‰©ä»¶)ã€‚
  
pre
  code.ruby
    | class A < BasicObject
      end

      a = A.new
      # p a.say # undefined method `say' for #<A:0x007f8665876110> (NoMethodError)

      a.instance_eval do
        def say
          'Hello'
        end
      end

      p a.say

h1 Callable Objects
p 
  | Blockåªæ˜¯æ‰€è¬‚å¯è¢«å‘¼å«ç‰©ä»¶(Callable Object)çš„å…¶ä¸­ä¸€ç¨®ï¼Œå¯å‘¼å«ç‰©ä»¶å°±æ˜¯å°‡ç¨‹å¼ç¢¼æš«å­˜èµ·ä¾†ï¼Œè€Œç­‰éä¸€æ®µæ™‚é–“ä¹‹å¾Œå†ä¾†å‘¼å«(package code first, call it later)ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥å…ˆå®šç¾©è¦åŸ·è¡Œçš„ç¨‹å¼ç¢¼è€Œä¸ç”¨ç«‹åˆ»å‘¼å«å®ƒã€‚åœ¨rubyä¸­è‡³å°‘æœ‰ä¸‰ç¨®å¯è¢«å‘¼å«çš„ç‰©ä»¶ï¼š
ul
  li proc å³æ˜¯è½‰æˆç‰©ä»¶å‹å¼çš„ blockã€‚
  li lambda åŒæ¨£æ˜¯è½‰æˆç‰©ä»¶å‹å¼çš„ blockï¼Œä½†ä½¿ç”¨ä¸Šèˆ‡ proc æœ‰äº›è¨±çš„ä¸åŒã€‚
  li method å°±æ˜¯ methodã€‚
  
h2 Proc Objects

p 
  | å› ç‚º block ä¸æ˜¯ç‰©ä»¶ï¼Œæ‰€ä»¥æ²’è¾¦æ³•åšåˆ°æš«å­˜ä¹‹å¾Œå†å‘¼å«çš„éœ€æ±‚ã€‚åœ¨rubyä¸­å¯ä»¥ä½¿ç”¨ Proc ä¾†å°‡ block ç‰©ä»¶åŒ–ï¼Œæ–¹å¼å¦‚ä¸‹ï¼š
pre
  code.ruby
    | add_one = Proc.new { |x| x + 1 }
      p add_one.call(1) # 2
p 
  | ä¸Šé¢çš„ç¨‹å¼ç¢¼å…ˆä½¿ç”¨ Proc.new å»ºç«‹ä¸€å€‹ add_one çš„ procï¼Œé€™å€‹æ™‚å€™ add_one å„²å­˜äº† block { |x| x + 1 }ï¼Œæˆ‘å€‘å¯ä»¥ä½¿ç”¨ call é€™å€‹ methodä¾†åŸ·è¡Œ block çš„ç¨‹å¼ã€‚å°‡ç¨‹å¼ç¢¼æš«å­˜èµ·ä¾†ï¼Œè€Œç­‰éä¸€æ®µæ™‚é–“ä¹‹å¾Œå†ä¾†å‘¼å«çš„æŠ€å·§ç¨±åš
  span.mk-blue Deferred Evaluation
  | ã€‚é™¤äº†ä¸Šé¢é€™å€‹æ–¹å¼å¯ä»¥å»ºç«‹ Procï¼Œé‚„æœ‰ä¸‹é¢é€™å¹¾ç¨®å»ºç«‹ Proc çš„æ–¹æ³•ï¼š
pre
  code.ruby
    | add_one = lambda { |x| x + 1 }
      p add_one.call(1) # 2

      add_one = -> (x) { x + 1 }
      p add_one.call(1) # 2
p 
  | ä¸Šé¢é€™å…©å€‹å¯«æ³•åšçš„äº‹æ˜¯ä¸€æ¨£çš„ã€‚

h3 The & Operator

p 
  | å¦‚æœæˆ‘å€‘è¦åœ¨æŸå€‹ method è£¡ä½¿ç”¨ blockï¼Œé€šå¸¸éƒ½æ˜¯ä½¿ç”¨ yield çš„æ–¹å¼ä¾†ä½¿ç”¨ï¼Œä¸éåœ¨æŸäº›æƒ…æ³ä¸‹ yield æ˜¯æ²’è¾¦æ³•è™•ç†çš„ã€‚ä¾‹å¦‚ï¼š
ul
  li è¦å°‡å‚³é€²ä¾†çš„ block å†æ¬¡å‚³çµ¦å¦ä¸€å€‹ method æˆ–æ˜¯å¦ä¸€å€‹ block ä¸­ã€‚
  li è¦å°‡å‚³é€²ä¾†çš„ block è½‰æˆ procã€‚
p 
  | é€™å…©ç¨®æƒ…æ³éƒ½æ˜¯å› ç‚ºä½¿ç”¨ yield å°±åƒæŠŠ block è¦–åšä¸€å€‹æ²’æœ‰åå­—çš„ method ä¾†è™•ç†ï¼Œè€Œä¸Šé¢çš„æƒ…æ³æ˜¯è¦æŒ‡å®šé€™å€‹ block åšä¸€äº›äº‹æƒ…ï¼Œæ‰€ä»¥æˆ‘å€‘è¦çµ¦å‚³é€²ä¾†çš„ block ä¸€å€‹åå­—ï¼Œæ–¹å¼å°±æ˜¯ä½¿ç”¨ & é€™å€‹ operatorã€‚æ–¹å¼å¦‚ä¸‹ï¼š
  
i é€™æ˜¯åŸæœ¬ä½¿ç”¨ yield çš„å¯«æ³•ï¼š  
pre
  code.ruby
    | def do_math(a, b)
        yield(a, b)
      end

      p do_math(1, 2) { |x, y| x + y } # 3
      
i é€™æ˜¯ä½¿ç”¨ & çš„å¯«æ³•ï¼š  
pre
  code.ruby
    | def do_math(a, b, &c)
        c.call(a, b)
      end

      p do_math(1, 2) { |x, y| x + y } # 3
p 
  | ä½ æœƒç™¼ç¾ä½¿ç”¨ & å‚³é€²ä¾†çš„ block æœƒè¢«è‡ªå‹•è½‰æˆ proc ä¸¦ä¸”å°‡å®ƒå­˜åœ¨ä¸€å€‹åƒæ•¸è£¡(ä¸Šé¢çš„ä¾‹å­å°±æ˜¯ c é€™å€‹åƒæ•¸)ï¼Œé€™æ™‚å€™æˆ‘å€‘å°±å¯ä»¥é€éé€™å€‹ proc ä¾†åšä¸€äº›äº‹æƒ…ï¼Œé€™ä¹Ÿæ˜¯å°‡ block è½‰æˆ proc çš„å¦ä¸€ç¨®æ–¹å¼ã€‚ & å¦ä¸€å€‹ç”¨é€”æ˜¯å°‡ proc è½‰å› blockï¼Œæ–¹å¼å¦‚ä¸‹ï¼š
pre
  code.ruby
    | def do_math(a, b)
        yield(a, b)
      end

      do_add = Proc.new { |x, y| x + y }

      p do_math(1, 2, &do_add) # 3
p 
  | ä¸Šé¢çš„ä¾‹å­åœ¨å‘¼å« do_math çš„æ™‚å€™ï¼Œä¸å¸¶ blockï¼Œè€Œæ˜¯åœ¨æœ€å¾Œä¸€å€‹åƒæ•¸å‚³å…¥ do_add é€™å€‹ procï¼Œä¸¦ä¸”åŠ ä¸Š & ï¼Œé€™æ™‚å€™åœ¨ do_math è£¡çš„ yield å°±æœƒä½¿ç”¨ do_add è£¡å®šç¾©çš„ç¨‹å¼ç¢¼ã€‚ 

h3 The HighLine Example
h2 Procs vs. Lambdas
p 
  | rubyè£¡æœ€å¸¸ææ··çš„æ±è¥¿å°±æ˜¯ Proc.new èˆ‡ lambda æ‰€ç”¢ç”Ÿçš„ procï¼Œå¦‚æœä½ ç”¨ .class å»çœ‹å®ƒå€‘ç”¢ç”Ÿçš„ç‰©ä»¶ï¼Œå®ƒå€‘éƒ½æ˜¯ Procï¼š
pre
  code.ruby
    | proc_from_proc_new = Proc.new do |x|
        x + 1
      end

      p proc_from_proc_new.class # Proc
      p proc_from_proc_new.call(1) # 2

      proc_from_lambda = lambda do |x|
        x + 1
      end

      p proc_from_lambda.class # Proc
      p proc_from_lambda.call(1) # 2
p 
  | ä½†å¯¦éš›ä¸Šé€™å…©å€‹ proc é‚„æ˜¯æœ‰ä¸€äº›å·®ç•°ï¼Œè€Œä¸”é€™äº›å·®ç•°å¤§åˆ°è¦ç”¨ä¸åŒçš„åç¨±ä¾†ç¨±å‘¼é€™å…©ç¨® procï¼Œå¦‚æœæ˜¯ç”¨ Proc.new ç”¢ç”Ÿçš„ proc ç¨±åš
  span.mk-blue proc
  | ï¼Œç”¨ lambda ç”¢ç”Ÿçš„ proc ç¨±åš
  span.mk-blue lambda
  | ã€‚
  
h3 Procs, Lambdas, and return

p 
  | ç¬¬ä¸€å€‹æœ€å¤§çš„å·®åˆ¥æ˜¯ return çš„è¡Œç‚ºï¼Œå¦‚æœæ˜¯åœ¨ä¸€å€‹ method è£¡å»ºç«‹ procï¼Œè€Œé€™å€‹ proc è£¡åˆæœ‰ return çš„è©±ï¼Œä½¿ç”¨ Proc.new èˆ‡ lambda çš„è¡Œç‚ºæœƒä¸åŒï¼Œèˆ‰å€‹ä¾‹å­ï¼š
pre
  code.ruby
    | def do_math_proc_new(a)
        proc_from_proc_new = Proc.new do |x|
          return (x + 1)
        end
        result = proc_from_proc_new.call(a)
        result = result * 2
        result
      end

      p do_math_proc_new(1) # 2

      def do_math_lambda(a)
        proc_from_lambda = lambda do |x|
          return (x + 1)
        end
        result = proc_from_lambda.call(a)
        result = result * 2
        result
      end

      p do_math_lambda(1) # 4
p 
  | ä¸Šé¢çš„ä¾‹å­ä½ æœƒç™¼ç¾ä½¿ç”¨ Proc.new ç®—å‡ºä¾†çš„å€¼ä¸¦æ²’æœ‰ * 2ï¼Œé€™æ˜¯å› ç‚º do_math_proc_new åœ¨ result = proc_from_proc_new.call(a) çš„æ™‚å€™å› ç‚º proc_from_proc_new è£¡é¢æœ‰å®šç¾© return ï¼Œè€Œé€™å€‹ return æœƒå°è‡´ do_method_proc_new æœƒè¢« return è€Œææ—©çµæŸåŸ·è¡Œï¼Œæ‰€ä»¥ result = result * 2 åè€Œæ²’æœ‰åŸ·è¡Œåˆ°ã€‚å¦‚æœæˆ‘å€‘æŠŠ proc_from_proc_new å¾ do_math_proc_new ä¸­æ¬åˆ°å¤–é¢åŸ·è¡Œï¼Œå°±æœƒå‡ºç¾ä¸‹é¢çš„ errorï¼š
pre
  code.ruby
    | proc_from_proc_new = Proc.new do |x|
        return (x + 1)
      end

      p proc_from_proc_new.call(1) # in 
    = '`block in <main>\': unexpected return (LocalJumpError)'
p 
  | é€™æ˜¯å› ç‚ºä¸Šé¢çš„ç¨‹å¼ç¢¼å˜—è©¦å¾ top-level returnï¼Œé€™æ²’è¾¦æ³•åšåˆ°ï¼Œæ‰€ä»¥å°±å‡º exception äº†ã€‚è¦è®“ Proc.new çš„ proc å¯ä»¥æ­£ç¢ºé‹ä½œï¼Œåªè¦æŠŠ return æ‹¿æ‰å°±å¯ä»¥äº†ï¼š
pre
  code.ruby
    | proc_from_proc_new = Proc.new do |x|
        x + 1
      end

    p proc_from_proc_new.call(1) # 2
p 
  | ç›¸è¼ƒæ–¼ Proc.newï¼Œlambda è£¡çš„ return å°±ä¸æœƒæœ‰é€™å€‹è¡Œç‚ºï¼Œæ˜¯æ¯”è¼ƒç¬¦åˆæˆ‘å€‘çš„é æœŸã€‚

h3 Procs, Lambdas, and Arity

p
  | arity æŒ‡çš„å°±æ˜¯æ¥æ”¶çš„åƒæ•¸å€‹æ•¸ï¼Œ proc èˆ‡ lambda çš„ç¬¬äºŒå€‹å·®ç•°æ˜¯å° arity çš„å®¹éŒ¯åº¦ï¼Œä¹Ÿå°±æ˜¯ç•¶æ¥æ”¶åˆ°èˆ‡é æœŸä¸åŒçš„åƒæ•¸å€‹æ•¸æ™‚ï¼Œproc èˆ‡ lambdaæœ‰ä¸åŒçš„è™•ç†æ–¹å¼ï¼š

pre
  code.ruby
    | proc_from_proc_new = Proc.new do |a, b|
        [a, b]
      end
      p proc_from_proc_new.arity # 2
      p proc_from_proc_new.call(1, 2) # [1, 2]
      p proc_from_proc_new.call(1) # [1, nil]
      p proc_from_proc_new.call(1, 2, 3) # [1, 2]

      proc_from_lambda = lambda do |a, b|
        [a, b]
      end
      p proc_from_lambda.arity # 2
      p proc_from_lambda.call(1, 2) # [1, 2]
      p proc_from_lambda.call(1) # 
    = 'in `block in <main>\': wrong number of arguments (1 for 2) (ArgumentError)' + "\n"
    | p proc_from_lambda.call(1, 2, 3) #
    = 'in `block in <main>\': wrong number of arguments (3 for 2) (ArgumentError)'
p 
  | å¾ä¾‹å­å¯ä»¥ç™¼ç¾ proc æœƒè©¦è‘—è®€å–å‚³å…¥çš„åƒæ•¸ï¼Œå¦‚æœå°‘äº†å°±æœƒè®Šæˆnilï¼Œå¤šäº†å‰‡æœƒç•¥éã€‚è€Œ lambda æœƒåšæ¯”è¼ƒåš´æ ¼çš„æª¢æŸ¥ï¼Œåªè¦åƒæ•¸ä¸å°å°±æœƒå‡º exceptionã€‚

h3 Procs vs. Lambdas: The Verdict

p 
  | æ‰€ä»¥åˆ°åº•è¦ç”¨ Proc.new é‚„æ˜¯ç”¨ lambda å‘¢ï¼Ÿå¤§éƒ¨åˆ†çš„rubyisté‚„æ˜¯æœƒå»ºè­°å¦‚æœå¯ä»¥ç”¨ lambda å°±ç”¨ lambdaï¼Œå› ç‚º return çš„è¡Œç‚ºæ¯”è¼ƒåƒ methodï¼Œè€Œä¸”å°åƒæ•¸åˆ—ä¹Ÿæ¡å–æ¯”è¼ƒåš´è¬¹çš„æª¢æŸ¥ã€‚

h2 Method Objects

p 
  | é™¤äº† proc èˆ‡ lambda å¤–ï¼Œ method ä¹Ÿæ˜¯å¦ä¸€ç¨®å¯è¢«å‘¼å«çš„ç‰©ä»¶ã€‚ä¾‹å­å¦‚ä¸‹ï¼š
pre
  code.ruby
    | class A
        def initialize(word)
          @word = word
        end

        def say
          @word
        end
      end

      a = A.new('Hi')

      do_say = a.method(:say)
      p do_say.call # Hi
      p do_say.class # Method
p 
  | æˆ‘å€‘å¯ä»¥ä½¿ç”¨ Kernel#method å°‡ä¸€å€‹ç‰©ä»¶è£¡çš„ method è®Šæˆä¸€å€‹ç‰©ä»¶åŒ–çš„ methodï¼Œé€™æ¨£å°±å¯ä»¥ä½¿ç”¨ call åšåˆ°å»¶å¾Œå‘¼å«çš„æ•ˆæœã€‚BTWï¼Œæœ‰å¦ä¸€å€‹ Kernel#singleton_method å¯ä»¥æŠŠä¸€å€‹ç‰©ä»¶è£¡çš„ singleton method è½‰æˆç‰©ä»¶åŒ–çš„ methodï¼Œä¸éç­‰åˆ°ä¸‹ä¸€ç« æ‰æœƒä»‹ç´¹ä»€éº¼æ˜¯ singleton methodã€‚
  
p 
  | é‚£ method èˆ‡ proc / lambda åˆ°åº•æ˜¯å·®åœ¨ä»€éº¼åœ°æ–¹å‘¢ï¼Ÿæœ€å¤§çš„å·®åˆ¥åœ¨æ–¼ method å®ƒæ‰€åƒç…§åˆ° scope æ˜¯å±¬æ–¼ç‰©ä»¶æœ¬èº«(ä¹Ÿå°±æ˜¯ä¸Šé¢çš„ instance aï¼Œæ‰€ä»¥æ‰å¯ä»¥ä½¿ç”¨ @word é€™å€‹ instance variable)ï¼Œè€Œ proc / lambda å‰‡æ˜¯åƒç…§å®ƒè¢«å®£å‘Šå®šç¾©çš„æ™‚å€™æ‰€åœ¨çš„ scope (å› ç‚ºæˆ‘å€‘æ˜¯ä½¿ç”¨ block ä¾†å®£å‘Šå®šç¾© proc / lambdaï¼Œè€Œ block æœ‰ closure çš„ç‰¹æ€§ï¼Œä¹Ÿå°±æ˜¯å®ƒæ˜¯åƒç…§ block è¢«å®£å‘Šå®šç¾©æ™‚æ‰€åœ¨çš„ scopeã€‚)

h3 Unbound Methods

p 
  | ä¸Šé¢çš„ä¾‹å­ instance method say æ‰€åƒç…§çš„æ˜¯å°æ‡‰å®ƒæ‰€å±¬çš„ instance aï¼Œä½†å¦‚æœæ˜¯ä¸€å€‹ module çš„ method è¢«ç‰©ä»¶åŒ–ï¼Œé‚£å®ƒæ‰€åƒç…§çš„æ˜¯ä»€éº¼æ±è¥¿å‘¢ï¼Ÿ
pre
  code.ruby
    | module B
        def say
          'Hello'
        end
      end

      do_say = B.instance_method(:say)
      p do_say.call # 
    = 'in `<main>\': undefined method `call\' for #<UnboundMethod: B#say> (NoMethodError)' + "\n"
    | p do_say.class # UnboundMethod
p 
  | module çš„ method è¢«ç‰©ä»¶åŒ–æœƒè®Šæˆæ‰€è¬‚çš„ UnboundMethod ï¼Œå®ƒæ²’è¾¦æ³•ç›´æ¥è¢«å‘¼å«ï¼Œä½†å®ƒå¯ä»¥åšå¾ˆç¥å¥‡çš„äº‹æƒ…ï¼š
pre
  code.ruby
    | String.class_eval do
        define_method(:say, do_say)
      end

      p 'Yoooo'.say # Hello
p 
  | UnboundMethod å¯ä»¥ä½¿ç”¨ define_method è¢«é‡æ–°ç¶å®š(bind)åˆ°å…¶å®ƒçš„ classï¼Œä¸éé€™æ¨£çš„ç”¨æ³•çœŸçš„æ˜¯å¾ˆå°‘è¦‹å•Šã€‚

h3 The Active Support Example

p 
  | æ›¸ä¸Šèˆ‰äº†ä¸€å€‹ Active Support ä½¿ç”¨ UnboundMethod çš„ç¯„ä¾‹ã€‚åœ¨é€™å€‹ç¯„ä¾‹ä¹Ÿæåˆ°äº†å¦‚æœä½¿ç”¨ UnboundMethod ä¾†åš bindæœƒé€ æˆmethod lookupçš„é †åºæ··äº‚ï¼Œæ‰€ä»¥é‚„æ˜¯èƒ½ç›¡é‡ä¸ç”¨æ¯”è¼ƒå¥½ã€‚

h2 Callable Objects Wrap-Up

p 
  | æ¥ä¸‹ä¾†çš„å…©å€‹ç« ç¯€ï¼Œä½œè€…ä½¿ç”¨äº†ä¹‹å‰æåˆ°çš„ meta-programming çš„æŠ€å·§å¯¦ä½œäº†ä¸€çµ„DSLã€‚

h1 Writing a Domain-Specific Language
h2 Your First DSL
h3 Sharing Among Events

h1 Quiz: A Better DSL
h2 Runaway Bill
h2 Quiz Solution
h2 Removing the â€œGlobalâ€ Variables
h3 Adding a Clean Room

h1 Wrap-Up
