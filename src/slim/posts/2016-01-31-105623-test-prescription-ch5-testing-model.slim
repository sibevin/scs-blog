.meta-data title railsè®€æ›¸æœƒ - Test Prescription - Ch.5 æ¸¬è©¦model
.meta-data datetime 2016-01-31 10:56:23
.meta-data tags rails,test,book_tp,rails_study-group
.meta-data category coding
.meta-data link test-prescription-ch5-testing-model
.meta-data file 2016-01-31-105623-test-prescription-ch5-testing-model
.meta-data template post
.meta-data end

ul
  li
    | Modelä¸åªæ˜¯ActiveRecordï¼Œå®ƒé‚„å¯ä»¥æ˜¯serviceã€value objectsæˆ–æ˜¯ä¸€äº›åŒ…å«å•†æ¥­é‚è¼¯çš„ç´”rubyçš„classã€‚
  li
    | Modelç›¸è¼ƒæ–¼controllerã€viewï¼Œæ˜¯èˆ‡railsä¾è³´ç¨‹åº¦æ¯”è¼ƒä½çš„éƒ¨åˆ†ï¼Œæ‰€ä»¥å¾ˆé©åˆå¾modelé–‹å§‹å¯«æ¸¬è©¦ã€‚
    
h1 What Can We Do in a Model Test?

i
  | spec/models/post_spec.rb 
pre
  code.ruby
    | require "rails_helper"
    
      RSpec.describe Post, :type => :model do
        context "with 2 or more comments" do
          it "orders them in reverse chronologically" do
            post = Post.create!
            comment1 = post.comments.create!(:body => "first comment")
            comment2 = post.comments.create!(:body => "second comment")
            expect(post.reload.comments).to eq([comment2, comment1])
          end
        end
      end
      
h1 What Makes a Good Set of Model Tests?
p 
  | æ¸¬è©¦çš„åŸºæœ¬æµç¨‹ï¼šwrite a simple test, make it pass, then refactor
h2 A TDD Metaprocess
p
  | å•†æ¥­é‚è¼¯æ˜¯è¤‡é›œçš„è€Œä¸”åœ¨ä¸€é–‹å§‹è¦æ€éº¼å¯¦åšéƒ½é‚„æ²’å®Œå…¨å®šæ¡ˆã€‚æ‡‰è©²è¦è‘—é‡åœ¨æµç¨‹ï¼Œä¸¦å°‡åŠŸèƒ½åˆ‡æˆæ›´å°çš„æ­¥é©Ÿã€‚
ol
  li 
    | å¯«model testçš„ä¸€å€‹å¥½çš„é–‹å§‹å°±æ˜¯å¾ã€Œæè¿°åˆå§‹åŒ–ç‹€æ…‹ã€è‘—æ‰‹ï¼Œå°¤å…¶æ˜¯ä½¿ç”¨TDDä¾†å»ºç«‹ä¸€å€‹æ–°çš„classï¼Œå› ç‚ºåˆå§‹åŒ–ç‰½æ¶‰çš„å•†æ¥­é‚è¼¯æœ€å°‘ã€‚
  li
    | æ¥è‘—é‡å°å•†æ¥­é‚è¼¯å…ˆå¯«ä¸€å€‹æˆåŠŸçš„æ¡ˆä¾‹æˆ–è·¯å¾‘ï¼Œä¸å»ºè­°åŒæ™‚å¯«å¤±æ•—çš„æ¡ˆä¾‹ï¼Œå› ç‚ºæœƒé€ æˆæ··æ·†ï¼Œä½†å¯ä»¥å…ˆå°‡å®ƒå€‘å¯«æˆè¨»è§£æˆ–pending caseã€‚
  li 
    | å¯«å®ŒæˆåŠŸæ¡ˆä¾‹ï¼Œæ¥è‘—å°±æ˜¯å¯«ä¸€äº›å¤±æ•—çš„ä¾‹å­ã€‚å¤±æ•—çš„æ¡ˆä¾‹æœƒè®“ç¨‹å¼ç¢¼è¶Šä¾†è¶Šè¤‡é›œï¼Œé€™æ™‚refactorå°±æœƒè®Šçš„å¾ˆé‡è¦ã€‚ä¸€æ—¦ä½ çš„ç¨‹å¼é€šéäº†é€™äº›å¤±æ•—çš„æ¡ˆä¾‹ï¼Œè€Œä¸”ä¹Ÿæ‰¾ä¸åˆ°å…¶å®ƒçš„å¤±æ•—æ¡ˆä¾‹ï¼Œé‚£å°±åšå®Œå•¦ã€‚
p
  | slimingï¼šç”¨ç°¡å–®çš„æ–¹å¼å…ˆé€šéæ¸¬è©¦ï¼Œä¾‹å¦‚ï¼šä»€éº¼éƒ½ä¸åšåªå›å‚³ä¸€å€‹æ•¸å€¼ï¼Œç­‰ä¹‹å¾Œçš„éšæ®µåœ¨ä¾†æ”¹ã€‚é€™éº¼åšçš„å¥½è™•åœ¨æ–¼åœ¨ä¸€é–‹å§‹å¯ä»¥ä¸ç”¨å¤ªè‘—é‡åœ¨å¯¦åšçš„ç´°ç¯€ã€‚
p
  | ä¸€å€‹model specçš„ç¯„ä¾‹ï¼š
i
  | spec/models/project_spec.rb 
pre
  code.ruby
    | require "rails_helper"
      
      RSpec.describe Project do
        describe "initialize" do
          it "should have a default name" do
            expect(Project.new).to eq("New Project")
          end
        end
        
        describe ".total_size" do
          let(:project) { create(:project) }
          
          it "should return the total task size" do
            task_size = rand(10) + 1
            create(:task, project: project, size: task_size)
            expect(project.total_size).to eq(task_size)
          end
          
          it "should return the total task size if multiple tasks are given" do
            task_size1 = rand(10) + 1
            task_size2 = rand(10) + 1
            create(:task, project: project, size: task_size1)
            create(:task, project: project, size: task_size2)
            expect(project.total_size).to eq(task_size1 + task_size2)
          end
          
          it "should return 0 if no task in the project" do
            expect(project.total_size).to eq(0)
          end
          
          it "should return nil if there is a nil size task in the project" do
            create(:task, project: project, size: nil)
            expect(project.total_size).to be_nil
          end    
        end
      end
      
h1 Refactoring Models
p è¨±å¤šçš„è¨­è¨ˆæœƒåœ¨refactorçš„æ™‚å€™ç™¼ç”Ÿï¼Œé€šå¸¸å°±æ˜¯cleanupï¼Œä¹Ÿå°±æ˜¯æŠŠå¯«çš„å¾ˆç³Ÿæˆ–æ˜¯æ¶æ§‹ä¸å¥½çš„ç¨‹å¼ç¢¼é‡æ–°å®‰æ’ã€‚è«‹ä¸è¦è·³érefactorçš„æ­¥é©Ÿï¼Œå®ƒæ˜¯ä¸€å€‹ç”¨ä¾†æ€è€ƒèˆ‡è¨­è¨ˆæ€éº¼å¯«ç¨‹å¼çš„æ–¹æ³•ï¼Œè€Œä¸”ä¿ç•™ç³Ÿç³•çš„ç¨‹å¼ç¢¼åªæœƒè®“ä¹‹å¾Œrefactorè¶Šä¾†è¶Šç—›è‹¦ã€‚

h2 Break Up Complexity
p å°‡é•·çš„methodæˆ–codeåˆ‡æˆå¤šå€‹å°çš„methodï¼Œå¥½è™•æ˜¯å› ç‚ºç¨‹å¼å€å¡Šæ”¾åœ¨å°methodä¸­ï¼Œè€Œmethodå‘½åå¯ä»¥ç‚ºç¨‹å¼å¸¶ä¾†å¯è®€æ€§ã€‚
p é€šå¸¸æœ‰å¹¾å€‹åœ°æ–¹æ˜¯å¯ä»¥è€ƒæ…®åˆ‡æˆå°methodï¼š
ul
  li ä»»ä½•è¤‡é›œçš„booleané‹ç®—å¼
  li å€åŸŸè®Šæ•¸ï¼Œå¤§é‡çš„å€åŸŸè®Šæ•¸æœƒé€ æˆrefactoré›£ä»¥åŸ·è¡Œã€‚
  li å‡ºç¾ä¸€è¡Œè¨»è§£çš„åœ°æ–¹ã€‚
h2 Combine Duplication
p duplicationæœ‰ä¸‰ç¨®ï¼š
ul
  li duplication of fact
  li duplication of logic
  li duplication of structure
  
h2 Duplication of fact
p å°±æ˜¯Magic number
pre
  code.ruby
    | validates :size, numericality: {less_than_or_equal_to: 5}
      def 
        possible_sizes (1 .. 5)
      end 

      validates :size, numericality: {less_than_or_equal_to: MAX_POINT_COUNT}
      def possible_sizes
        (1 .. MAX_POINT_COUNT)
      end
      
      VALID_POINT_RANGE = 1 .. 5
      validates :size, inclusion: {in: VALID_POINT_RANGE}

p ä¹Ÿå¯ä»¥é¸æ“‡å°‡æ•¸å€¼æ”¾åœ¨ä¸€å€‹methodä¸­ï¼Œé€™æ¨£åšçš„å¥½è™•æ˜¯æœ‰æ™‚å€™instanceçš„methodæœƒæ¯”classçš„variableä¾†çš„æ–¹ä¾¿ä½¿ç”¨ï¼Œå¦ä¸€æ–¹é¢ä¹Ÿä¿ç•™æœªä¾†éœ€è¦è®Šæˆè®Šæ•¸çš„å¯èƒ½æ€§ã€‚
pre
  code.ruby
    | def max_point_count
        5
      end 

h2 Duplication of logic
pã€Œè¤‡é›œçš„booleané‹ç®—å¼ã€æˆ–æ˜¯ã€Œæ•£ä½ˆåœ¨å¾ˆå¤šåœ°æ–¹ç°¡å–®ä½†ç›¸åŒçš„è¨ˆç®—é‚è¼¯ã€ã€‚
pre
  code.ruby
    | class User
        def maximum_posts
          if status == :trusted then 10 else 5 end
        end
        def urls_in_replies
          if status == :trusted then 3 else 0 end
        end
      end 

      class User
        def maximum_posts
          if trusted? then 10 else 5 end
        end
        def urls_in_replies
          if trusted? then 3 else 0 end
        end
        
        def trusted?
          status == :trusted
        end
      end 
p è¦æ³¨æ„çš„æ˜¯ï¼Œä¸æ˜¯æ‰€æœ‰çœ‹èµ·ä¾†åƒçš„ç¨‹å¼ç¢¼éƒ½è¦åˆ‡å‡ºä¾†æ”¾åœ¨ä¸€èµ·ã€‚

h2 Find Missing Abstractions
p Duplication of structureè¡¨ç¤ºæœ‰missing abstractionï¼Œé€™æ„å‘³è‘—éœ€è¦æŠŠç¨‹å¼ç¢¼æ¬åˆ°å¦ä¸€å€‹classã€‚
p ä¸€å€‹æ˜é¡¯çš„ä¾‹å­æ˜¯ã€Œé‡è¤‡å‡ºç¾çš„ä¸€æ•´çµ„methodã€æˆ–æ˜¯ã€Œä¸€çµ„methodæœ‰ç›¸åŒçš„prefixæˆ–æ˜¯suffixï¼Œä¾‹å¦‚ï¼šlogger_initã€logger_printã€logger_readã€ã€‚

pre
  code.ruby
    | class User < ActiveRecord::Base
        # ... 
        def full_name
    = "\n" + '    "#{first_name} #{last_name}"' + "\n"
    |   end
        
        def sort_name
    = "\n" + '    "#{first_name}, #{last_name}"' + "\n"
    |   end
        # ...
      end 

      class Name
        attr_reader :first_name, :last_name
        def initialize(first_name, last_name) 
          @first_name, @last_name = first_name, last_name
        end
        
        def full_name
    = "\n" + '    "#{first_name} #{last_name}"' + "\n"
    |   end
        
        def sort_name
    = "\n" + '    "#{first_name}, #{last_name}"' + "\n"
    |   end
      end
      
      class User < ActiveRecord::Base
        delegate :full_name, :sort_name, to: :name 
        def name
           Name.new(first_name, last_name)
        end
      end 
p åˆ‡å‡ºName classçš„å¥½è™•ï¼š
ul
  li èˆ‡è³‡æ–™åº«çš„é‚è¼¯åˆ‡é–‹ï¼Œåªéœ€è¦æ¸¬è©¦å–®ç´”çš„é‹ç®—ï¼Œæ¸¬è©¦æ¯”è¼ƒå¥½å¯«(æ¸›å°‘æ¸¬è©¦æ™‚è¦åšçš„è¨­å®šï¼ŒåŠ å¿«æ¸¬è©¦æ™‚é–“)ã€‚
  li å®¹æ˜“æ“´å……åŠŸèƒ½ã€‚

p å•é¡Œï¼šç”¨concernå¯ä¸å¯ä»¥ï¼Ÿ
pre
  code.ruby
    | module Nameable
        extend ActiveSupport::Concern
        def full_name
    = "\n" + '    "#{first_name} #{last_name}"' + "\n"
    |   end
        
        def sort_name
    = "\n" + '    "#{first_name}, #{last_name}"' + "\n"
    |   end
      end
      
      class User < ActiveRecord::Base
        include Nameable 
      end 

p åœ¨ä¸€èˆ¬çš„æƒ…æ³ä¸‹ï¼Œåœ¨refactorç¨‹å¼æ™‚ä¸æ‡‰è©²å»æ”¹æ¸¬è©¦ï¼Œå› ç‚ºæ¸¬è©¦æ‡‰è©²è¦é‡å°ã€Œç¨‹å¼çš„åŠŸèƒ½è¡Œç‚ºã€å»å¯«è€Œä¸æ˜¯é‡å°å¯¦ä½œå»å¯«ã€‚æœ‰ä¸€å€‹ä¾‹å¤–å°±æ˜¯å¦‚æœç¨‹å¼ç¢¼è¢«æ¬åˆ°å¦ä¸€å€‹classï¼Œé‚£å°±è¦æ”¹æ¸¬è©¦äº†ã€‚
p å¦ä¸€å€‹å¯ä»¥æŠ½è±¡åŒ–çš„åœ°æ–¹å°±æ˜¯åœ¨æµç¨‹ä¸Šé‡è¤‡å‡ºç¾çš„åˆ¤æ–·ã€‚

pre
  code.ruby
    | def total_time
        if status == :completed
          calculate_completed_time
        else
          calculate_incompleted_time
        end 
      end
      
      def total_size
        if status == :completed
          calculate_completed_size
        else
          calculate_incompleted_size
        end 
      end

      def calculator 
        if complete?
          CompleteTaskCalculator.new(self)
        else
          IncompleteTaskCalculator.new(self)
        end
      end
      
      def total_time
        calculator.calculate_time
      end 
      
      def total_size
        calculator.calculate_size
      end 

h1 A Note on Assertions per Test
p ã€Œä¸€å€‹æ¸¬è©¦æ¡ˆä¾‹æ”¾ä¸€å€‹åˆ¤æ–·ã€v.s. ã€Œä¸€å€‹æ¸¬è©¦æ¡ˆä¾‹æ”¾å¤šå€‹åˆ¤æ–·ã€

pre
  code.ruby
    | it "marks a task complete" do
        task = tasks(:incomplete)
        task.mark_complete
        expect(task).to be_complete
        expect(task).to be_blocked
        expect(task.end_date).to eq(Date.today.to_s(:db)) expect(task.most_recent_log.end_state).to eq("completed")
      end 

      describe "task completion" do
        let(:task) {tasks(:incomplete)}
        before(:example) { task.mark_complete }
        specify { expect(task).to be_complete }
        specify { expect(task).to be_blocked }
        specify { expect(task.end_date).to eq(Date.today.to_s(:db)) }
        specify { expect(task.most_recent_log.end_state).to eq("completed") }
      end 

p ä¸€å€‹æ¸¬è©¦æ¡ˆä¾‹æ”¾ä¸€å€‹åˆ¤æ–·ï¼š
ul
  li å¥½è™•ï¼šæ¯å€‹åˆ¤æ–·éƒ½æ˜¯ç¨ç«‹çš„æ¡ˆä¾‹ï¼Œå³ä½¿å‰ä¸€å€‹åˆ¤æ–·å¤±æ•—äº†ï¼Œå¾Œé¢çš„åˆ¤æ–·é‚„å¯ä»¥ç¹¼çºŒåŸ·è¡Œï¼Œæ–¹ä¾¿åœ¨é–‹ç™¼åˆæœŸæ‰¾å‡ºæ¸¬è©¦æ²’æœ‰é€šéçš„åŸå› ã€‚
  li ç¼ºé»ï¼šæ¯å€‹æ¡ˆä¾‹éƒ½æœƒè·‘é‡è¤‡çš„setupèˆ‡teardownçš„å‹•ä½œï¼Œé€ æˆæ¸¬è©¦ç·©æ…¢ã€‚

p ä¸€å€‹æ¸¬è©¦æ¡ˆä¾‹æ”¾å¤šå€‹åˆ¤æ–·ï¼š
ul
  li èˆ‡ä¸Šé¢çš„å„ªç¼ºå‰›å¥½ç›¸åã€‚

p ä½œè€…çš„å»ºè­°ï¼š
ol
  li åœ¨é–‹ç™¼åˆæœŸæ¡ç”¨ã€Œä¸€å€‹æ¸¬è©¦æ¡ˆä¾‹æ”¾ä¸€å€‹åˆ¤æ–·ã€ï¼Œèƒ½å¿«é€Ÿæ‰¾å‡ºå•é¡Œã€‚
  li ç­‰åŠŸèƒ½ç©©å®šå¾Œï¼Œåˆä½µæˆã€Œä¸€å€‹æ¸¬è©¦æ¡ˆä¾‹æ”¾å¤šå€‹åˆ¤æ–·ã€ï¼ŒåŠ å¿«æ¸¬è©¦æ™‚é–“ã€‚
  li å¦‚æœé‡å°æŸå€‹åŠŸèƒ½è¦æ¸¬è©¦ä¸åŒæƒ…æ³çš„é‹ä½œï¼Œå°‡åˆ¤æ–·æ”¾åœ¨å„åˆ¥çš„æ¡ˆä¾‹æœƒæ¯”è¼ƒæ¸…æ¥šæ˜ç­ã€‚
  
h1 Testing What Rails Gives You
ul
  li railsæä¾›äº†associationèˆ‡validationå…©å€‹å¾ˆæ–¹ä¾¿çš„åŠŸèƒ½ï¼Œåªæ˜¯è¦æ€éº¼æ¸¬è©¦é€™äº›åŠŸèƒ½å‘¢ï¼Ÿ
  li åŸå‰‡ï¼šæ¸¬è©¦æ‡‰è©²è¦é‡å°ã€Œç¨‹å¼çš„åŠŸèƒ½è¡Œç‚ºã€å»å¯«è€Œä¸æ˜¯é‡å°å¯¦ä½œå»å¯«ã€‚æ¸¬è©¦associationï¼šæ‡‰è©²è¦æ¸¬è©¦æœƒç”¨åˆ°é—œè¯æ€§çš„åŠŸèƒ½ï¼Œè€Œä¸æ˜¯å»æª¢æŸ¥æœ‰æ²’æœ‰è¨­å®šassociationã€‚æ¸¬è©¦validationï¼šæ‡‰è©²è¦æ¸¬è©¦å¦‚æœçµ¦äº†ä¸å°çš„å€¼æœƒç”¢ç”Ÿæ€éº¼æ¨£çš„è¡Œç‚º(ä¾‹å¦‚ä¸æœƒå»ºç«‹è³‡æ–™)ï¼Œè€Œä¸æ˜¯å»æª¢æŸ¥æœ‰æ²’æœ‰è¨­å®švalidationã€‚
  li é¦¬ä¸Šæ‰“è‡‰shoulda-matchersï¼Œshoulda-matchersé¡çš„æ¸¬è©¦ä¸èƒ½ç®—æ˜¯TDDçš„åšæ³•ï¼ŒTDDæ‡‰è©²æ˜¯è¦å»æ€è€ƒåœ¨æŸå€‹åŠŸèƒ½ä¸‹æ˜¯ä¸æ˜¯çœŸçš„éœ€è¦associationæˆ–æ˜¯validationï¼Œè€Œä¸æ˜¯ä¸€é–‹å§‹å°±è¦è¨­æƒ³å¥½modelæœ‰å“ªäº›associationèˆ‡validationã€‚

h1 Testing ActiveRecord Finders
ul
  li ActiveRecordæä¾›äº†å¼·å¤§çš„sqlæŒ‡ä»¤(finder)ç”¨ä¾†queryè³‡æ–™ï¼Œåªæ˜¯è¦æ€éº¼æ¸¬è©¦é€™äº›åŠŸèƒ½å‘¢ï¼Ÿ
  li å¼·çƒˆçš„å»ºè­°å°‡å¸¸ç”¨çš„finderç¨ç«‹åˆ‡æˆmethodï¼Œå¥½è™•æ˜¯å¢åŠ å¯è®€æ€§èˆ‡å¥½æ¸¬è©¦ã€‚

pre
  code.ruby
    | class Task < ActiveRecord::Base
        def self.completed
          where(status: :completed)
        end
        
        def self.large
          where("size > 3")
        end
        
        def self.most_recent
          order("completed_at DESC")
        end
        
        def self.recent_done_and_large
          completed.large.most_recent.limit(5)
        end
      end 

p å•é¡Œï¼šç”¨scopeå¯ä¸å¯ä»¥ï¼Ÿ 

pre
  code.ruby
    | class Task < ActiveRecord::Base
        scope :completed, -> { where(status: :completed) }
        scope :large, -> { where("size > 3") }
        scope :most_recent, -> { order("completed_at DESC") }
        scope :recent_done_and_large, -> { completed.large.most_recent.limit(5) }
      end 

ul
  li å¦‚æœåˆ‡å‡ºä¾†çš„finder methodå·²ç¶“æœ‰æ¸¬è©¦coveräº†ï¼Œå°±ä¸ç”¨å†å¯«å¤šé¤˜çš„æ¸¬è©¦ä¾†æ¸¬è©¦å®ƒï¼Œå¦å¤–ä¹Ÿä¸æ‡‰è©²åœ¨å¯«ç¨‹å¼çš„æ™‚å€™å»æ”¹æ¸¬è©¦(å…¶å¯¦å°±æ˜¯followä¹‹å‰refactorçš„åŸå‰‡)ã€‚
  li ä½ å¿…é ˆæº–å‚™è¶³å¤ æ•¸é‡çš„è³‡æ–™ä¾†é©—è­‰åŠŸèƒ½æ˜¯å¦æ­£ç¢ºï¼Œä½†å¦ä¸€æ–¹é¢å› ç‚ºæ¸¬è©¦finderçš„è³‡æ–™ç‰½æ¶‰åˆ°å­˜å–è³‡æ–™åº«ï¼Œé€šå¸¸æœƒé€ æˆæ¸¬è©¦è®Šæ…¢ï¼Œæ‰€ä»¥è¦å„˜é‡æ¸›å°‘æ¸¬è©¦éœ€è¦ç”¨åˆ°çš„è³‡æ–™ã€‚
  li å¾å»ºç«‹å…©å€‹è³‡æ–™é–‹å§‹ï¼š

pre
  code.ruby
    | it "finds completed tasks" do
        complete = Task.create(completed_at: 1.day.ago, title: "Completed")
        incomplete = Task.create(completed_at: nil, title: "Not Completed") 
        expect(Task.complete.map(&:title)).to eq(["Completed"])
      end 
ul
  li å°æŠ€å·§ï¼šä¸æ˜¯å»æª¢æŸ¥`Task.complete`ï¼Œè€Œæ˜¯æª¢æŸ¥`Task.complete.map(&:title)`ã€‚
  li å¦‚æœè¦æ¸¬è¤‡æ•¸çš„finderï¼Œå°±éœ€è¦é¡å¤–çš„è³‡æ–™ï¼Œä½†åŸå‰‡é‚„æ˜¯ä¸€æ¨£ï¼šä¸€æ¬¡åŠ ä¸€å°ï¼Œä¸è¦åŠ è³‡æ–™è¶…ééœ€è¦çš„é‡ï¼Œä¸€å€‹æ¡ˆä¾‹ä¸€æ¬¡ä¸è¦æ¸¬å¤ªå¤šï¼Œåˆ‡æˆå°çš„æ¸¬è©¦æ¡ˆä¾‹ã€‚
  li æ¸¬è©¦æ’åºï¼šä¸è¦æ¸¬å·²ç¶“æ’å¥½çš„æ±è¥¿ï¼Œä¾‹å¦‚idï¼Œæ‡‰è©²è¦æ¸¬å¯ä»¥æ¯”è¼ƒå¤§å°çš„æ¬„ä½ï¼Œè€Œä¸”æ˜¯ä¾ç…§ã€Œä¸­ã€ã€ã€Œå¤§ã€ã€ã€Œå°ã€çš„å€¼å»å¡æ¸¬è©¦è³‡æ–™ã€‚

h1 Testing Shared Modules and ActiveSupport Concerns
p å¤šå€‹modelå¯èƒ½æœ‰é¡ä¼¼çš„åŠŸèƒ½æˆ–è¡Œç‚ºï¼Œæˆ‘å€‘å¯ä»¥ç”¨moduleæˆ–æ˜¯concernçš„æ–¹å¼è®“modelå…±ç”¨ç¨‹å¼ç¢¼ï¼Œä½†æ¸¬è©¦é€™ç¨®å…±ç”¨çš„è¡Œç‚ºæ˜¯ä¸€ç¨®æŒ‘æˆ°ã€‚é€™æ™‚å€™å°±æ˜¯shared exampleå‡ºå ´çš„æ™‚å€™å•¦ï¼š

i spec/support/size_group.rb 
pre
  code.ruby
    | RSpec.shared_examples "sizeable" do
        let(:instance) { described_class.new }
        
        it "knows a one-point story is small" do 
          allow(instance).to receive(:size).and_return(1)
          expect(instance).to be_small
        end
        
        it "knows a five-point story is epic" do
          allow(instance).to receive(:size).and_return(5)
          expect(instance).to be_epic
        end 
      end 

i spec/models/task_spec.rb 
pre
  code.ruby
    | RSpec.describe Task do
        it_should_behave_like "sizeable" 
        # ...
      end

i app/models/task.rb
pre
  code.ruby
    | class Task
        # ...
        def epic?
          size >= 5
        end
      
        def small?
          size <= 1
        end 
        # ...
      end



p RSpecé‚„æœ‰å…¶å®ƒæ–¹å¼å¯ä»¥ä½¿ç”¨shared exampleï¼š`include_example`ã€`it_behaves_like`æˆ–æ˜¯metadataç­‰ï¼Œè«‹åƒè€ƒCh15ã€‚
p å¯ä»¥ç”¨letç•¶å‚³é€é–€ï¼Œå°‡è®Šæ•¸å‚³çµ¦shared exampleã€‚

pre
  code.ruby
    | require "set"
      
      RSpec.shared_examples "a collection object" do
        describe "<<" do
          it "adds objects to the end of the collection" do
            collection << 1
            collection << 2
            expect(collection.to_a).to match_array([1, 2])
          end
        end
      end
      
      RSpec.describe Array do
        it_behaves_like "a collection object" do
          let(:collection) { Array.new }
        end
      end
      
      RSpec.describe Set do
        it_behaves_like "a collection object" do
          let(:collection) { Set.new }
        end
      end

p 
  | æ›´å¤šæœ‰é—œshared exampleçš„é‹ç”¨è«‹åƒè€ƒï¼š 
  a href="https://www.relishapp.com/rspec/rspec-core/docs/example-groups/shared-examples" target="_blank"
    | https://www.relishapp.com/rspec/rspec-core/docs/example-groups/shared-examples

h1 Write Your Own RSpec Matcher
p åœ¨RSpecä¸­å¯ä»¥å®¢è£½åŒ–è‡ªå·±çš„matcherã€‚ç¯„ä¾‹ï¼šå°‡`expect(project.size).to eq(5)`è®Šæˆ`expect(project).to be_of_size(5)`ã€‚

i spec/support/size_matcher.rb
pre
  code.ruby
    | RSpec::Matchers.define :be_of_size do |expected| 
        match do |actual|
          actual.total_size == expected 
        end
      end 

p å®¢è£½åŒ–matcherçš„ä½¿ç”¨æ–¹å¼èˆ‡ä¸€èˆ¬çš„matcherä¸€æ¨£

i spec/models/project_spec.rb
pre
  code.ruby
    | # ...
      it "can calculate total size" do 
        expect(project).to be_of_size(10) 
        expect(project).not_to be_of_size(5)
      end 
      # ...

p æ›´å¤šmatcherçš„å®¢è£½åŠŸèƒ½

i spec/support/size_matcher.rb
pre
  code.ruby
    | RSpec::Matchers.define :be_of_size do |expected|
        match do |actual|
          actual.total_size == expected
        end
      
        description do
    = "\n" + '    "have tasks totaling #{expected} points"' + "\n"
    |   end
      
        failure_message do |actual|
    = "\n" + '    "expected project #{actual.name} to have size #{expected}"' + "\n"
    |   end
      
        failure_message_when_negated do |actual|
    = "\n" + '    "expected project #{actual.name} not to have size #{expected}"' + "\n"
    |   end
      end 

p chainï¼šè®“ä½ çš„matcheræœ‰optionå¯ä»¥ä½¿ç”¨

i spec/support/size_matcher.rb
pre
  code.ruby
    | RSpec::Matchers.define :be_of_size do |expected|
        match do |actual|
          size_to_check = @incomplete ? actual.remaining_size : actual.total_size
          size_to_check == expected
        end
        # ...
        chain :for_incomplete_tasks_only do
          @incomplete = true
        end
      end
      
i spec/models/project_spec.rb
pre
  code.ruby
    | # ...
      it "can calculate total size" do
        expect(project).to be_of_size(10)
        expect(project).to be_of_size(5).for_incomplete_tasks_only 
      end 
      # ...

p 
  | æ›´å¤šæœ‰é—œcustom matcherçš„è³‡æ–™è«‹åƒè€ƒï¼š 
  a href="http://www.relishapp.com/rspec/rspec-expectations/v/3-4/docs/custom-matchers" target="_blank"
    | http://www.relishapp.com/rspec/rspec-expectations/v/3-4/docs/custom-matchers
